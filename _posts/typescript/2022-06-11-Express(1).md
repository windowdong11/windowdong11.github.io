---
title: "Express 뜯어보기"
date: 2022-05-24 02:00:00 +0900
categories: Backend
toc : true
---

## 요약

### 문제 상황

흔히 사용하는 코드는 아래와 같은 형태로 route를 다시 작성하고, route에 사용되는 변수들의 타입을 작성해줘야했다.  
```ts
interface RouteParams { id:string }
interface ResBody {...}
interface ReqBody {...}
interface ReqQuery {...}
interface Locals {...}

app.post('/route/:id',
  (
    req : Request<RouteParams, ReqBody, ResBody, ReqQuery, Locals>,
    res : Response<ResBody, Locals, StatusCode>
  ) => {...})

app.post<
  '/route/:id', RouteParams, ResBody, ReqBody, ReqQuery, Locals
>('/route/:id', (req, res) => {...})
```

이 코드를 아래처럼 작성하면 깔끔하고 좋아보인다.  
```ts
app.post<ResBody, ReqBody, ReqQuery, Locals>('/route/:id', (req, res) => {})
```

### 주로 사용하는 부분에 대해 이해

```ts
post: IRouterMatcher<this, 'post'>;

export interface IRouterMatcher<
    T,
    Method extends 'all' | 'get' | 'post' | 'put' | 'delete' | 'patch' | 'options' | 'head' = any
> {
    <
        Route extends string,
        P = RouteParameters<Route>,
        ResBody = any,
        ReqBody = any,
        ReqQuery = ParsedQs,
        Locals extends Record<string, any> = Record<string, any>
    >(

        path: Route,
        ...handlers: Array<RequestHandler<P, ResBody, ReqBody, ReqQuery, Locals>>
    ): T;
}
```

### 해결

가장 앞에 제네릭 인자 `Route, P`가 불편했기에, 뒤로 보내면 해결할 수 있었다.  
`Route, P`를 뒤로 옮겨주기 위해서, `Route`의 기본값을 string으로 넣어주고 뒤로 옮겼다.  
**예시)**  
```ts
// 변경 전
<
  Route extends string,
  P = RouteParameters<Route>,
  ResBody = any,
  ReqBody = any,
  ReqQuery = ParsedQs,
  Locals extends Record<string, any> = Record<string, any>
>

// 변경 후
<
  ResBody = any,
  ReqBody = any,
  ReqQuery = ParsedQs,
  Locals extends Record<string, any> = Record<string, any>,
  Route extends string = string,
  P = RouteParameters<Route>,
>
```

**전체)**  
```ts
export interface IRouterMatcher<
    T,
    Method extends 'all' | 'get' | 'post' | 'put' | 'delete' | 'patch' | 'options' | 'head' = any
> {
    <
        ResBody = any,
        ReqBody = any,
        ReqQuery = ParsedQs,
        Locals extends Record<string, any> = Record<string, any>,
        Route extends string = string,
        P = RouteParameters<Route>,
    >(
        path: Route,
        ...handlers: Array<RequestHandler<P, ResBody, ReqBody, ReqQuery, Locals>>
    ): T;
    <
        ResBody = any,
        ReqBody = any,
        ReqQuery = ParsedQs,
        Locals extends Record<string, any> = Record<string, any>,
        Path extends string = string,
        P = RouteParameters<Path>,
    >(
        path: Path,
        ...handlers: Array<RequestHandlerParams<P, ResBody, ReqBody, ReqQuery, Locals>>
    ): T;
    <
        ResBody = any,
        ReqBody = any,
        ReqQuery = ParsedQs,
        Locals extends Record<string, any> = Record<string, any>,
        P = ParamsDictionary,
    >(
        path: PathParams,
        ...handlers: Array<RequestHandler<P, ResBody, ReqBody, ReqQuery, Locals>>
    ): T;
    <
        ResBody = any,
        ReqBody = any,
        ReqQuery = ParsedQs,
        Locals extends Record<string, any> = Record<string, any>,
        P = ParamsDictionary,
    >(
        path: PathParams,
        ...handlers: Array<RequestHandlerParams<P, ResBody, ReqBody, ReqQuery, Locals>>
    ): T;
    (path: PathParams, subApplication: Application): T;
}
```

## 왜 이렇게 바뀌지 않았을까?

1. 다른 패키지들의 종속성 때문이 아닐까?
2. `IRouterHandler, Request`등에서 제네릭 인자들의 순서가 다 `P`로 시작해서 통일성 때문에?

### 관련 이슈를 찾아보자  

[Add overrides to IRouterMatcher](https://github.com/DefinitelyTyped/DefinitelyTyped/discussions/58564#discussion-3849769)  
이슈는 아니고 토론장에 딱 한명이 2월에 거의 같은 내용으로 글을 올렸다.  
`IRouterMatcher`의 타입을 재정의 할 수 있도록 해달라는 내용.  

[Shouldn't ResBody and ReqBody be declared as unknown instead of any?](https://github.com/DefinitelyTyped/DefinitelyTyped/issues/50967#issue-798658738)  
"`ResBody`가 `any`가 아닌 `unknown`으로 설정되어야 한다"는 의견.  
`unknown`으로 설정하면 타입을 `Route, RouteParam`을 두번 작성해야 한다.  



## 환경설정 & 실행(node, express, typescript, 파일들)

1. typescript, node, express, tsc-watch 설치  
2. npm start 스크립트 작성  
3. tsconfig 설정  
4. 실행해보기
5. 설정이 귀찮으면 클론 -> [repo](https://github.com/windowdong11/express-ts/tree/9d797c295d53ffb7f4a259431462a2e1f0a74488)

일단 환경부터 설정해보러, 고고~  

node + express + typescript + tsc-watch 설치  
```bash
npm i node express
npm i -D typescript @types/express tsc-watch
tsc --init
```


`package.json`에서 start 스크립트만 추가해줬다.  
```json
// package.json
{
  "scripts": {
    "start": "tsc-watch --noClear -p ./tsconfig.json --onSuccess \"node ./dist/index.js\""
  },
  "dependencies": {
    "express": "^4.18.1",
    "node": "^17.7.2"
  },
  "devDependencies": {
    "@types/express": "^4.17.13",
    "tsc-watch": "^5.0.3",
    "typescript": "^4.7.3"
  }
}
```

`tsconfig.json`에서 `rootDir`, `outDir`만 설정해줬다.  
```json
{
  "compilerOptions": {
    "target": "es5",
    "module": "commonjs",
    "rootDir": "./src/", // 추가
    "outDir": "./dist/", // 추가
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true
  }
}
```

환경 설정을 마쳤으니 돌아가는지 보자  
아래 코드를 작성하고 `npm start`를 실행하고 `localhost:3000`에 접속하면 `Hello World!`가 뜬다! 성공 :> (빵긋)
```ts
// src/index.ts
import express from "express"

const app = express()
const port = 3000

app.get('/', (req, res) => {
  res.send('Hello World!')
})

app.listen(port, () => {
  console.log(`Example app listening on port ${port}`)
})
```